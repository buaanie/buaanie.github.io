{"meta":{"title":"buaanie's blog","subtitle":null,"description":null,"author":"Nie Jian","url":"https://buaanie.github.io"},"pages":[],"posts":[{"title":"背包问题","slug":"背包问题","date":"2017-10-02T13:30:08.000Z","updated":"2017-10-02T16:18:07.501Z","comments":true,"path":"2017/10/02/背包问题/","link":"","permalink":"https://buaanie.github.io/2017/10/02/背包问题/","excerpt":"笔试时候遇到的动态规划问题比较多，背包问题比较有代表性，所以自己手动全部实现一遍，加深转移方程的推导与实现的记忆。下面依次介绍01背包（每种物品只有1个）、完全背包（每种物品有无限个）、多重背包（每种物品各有限制） 01背包背包容量为cubage，物品种类为cate种，物品i花费为cost[i]，价值为value[i]对于二维数组dp[i][j]表示容积为j放入前i种物品的最优解（价值最大值）//代码中注释都说的比较详细，就不展开了，中途会插入一些参考链接12345678910111213public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int cubage = sc.nextInt(); int cate = sc.nextInt(),i=1; int[] value = new int[cate+1]; int[] cost = new int[cate+1]; while(i&lt;=cate)&#123; cost[i]=sc.nextInt(); value[i]=sc.nextInt(); i++; &#125; parse01Normal(value,cost,cubage,cate);&#125;","text":"笔试时候遇到的动态规划问题比较多，背包问题比较有代表性，所以自己手动全部实现一遍，加深转移方程的推导与实现的记忆。下面依次介绍01背包（每种物品只有1个）、完全背包（每种物品有无限个）、多重背包（每种物品各有限制） 01背包背包容量为cubage，物品种类为cate种，物品i花费为cost[i]，价值为value[i]对于二维数组dp[i][j]表示容积为j放入前i种物品的最优解（价值最大值）//代码中注释都说的比较详细，就不展开了，中途会插入一些参考链接12345678910111213public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int cubage = sc.nextInt(); int cate = sc.nextInt(),i=1; int[] value = new int[cate+1]; int[] cost = new int[cate+1]; while(i&lt;=cate)&#123; cost[i]=sc.nextInt(); value[i]=sc.nextInt(); i++; &#125; parse01Normal(value,cost,cubage,cate);&#125; 下面是必须不装满的情况：状态转移方程：dp[i][j]= max(dp[i-1][j-k*cost[i]]+k*value[i]) , k=0|1如果需要还原最优解的物品，需要定义path[][]保存记录1234567891011121314151617181920212223242526272829303132333435363738private static void parse01Normal(int[] value, int[] cost, int cubage, int cate) &#123; int i=0,j=0; //dp[i][j]表示容量为j且物品种类为i个时的最优解（最大价值） int[][] dp = new int[cate+1][cubage+1]; //path[][]用于还原路径 int[][] path = new int[cate+1][cubage+1]; for(i=0;i&lt;=cate;i++)&#123; for(j=0;j&lt;=cubage;j++)&#123; if(i==0||j==0) dp[i][j]=0; else&#123; //dp[i][j]= max(dp[i-1][j-k*cost[i]]+k*value[i]) , k=0|1 // 先默认不放入，即此时容量为j也只放前i-1个物品 dp[i][j]=dp[i-1][j]; //如果容积够，并且放入之后价值提升（j-cost[i]容积下放入前i-1个商品前提下,再放入当前商品），则放入 if(cost[i]&lt;=j &amp;&amp; (dp[i-1][j-cost[i]]+value[i])&gt;dp[i-1][j]) &#123; dp[i][j] = dp[i - 1][j - cost[i]] + value[i]; path[i][j]=1; &#125; &#125; &#125; &#125; i--;j--; while(i&gt;0 &amp;&amp; j&gt;0)&#123; if(path[i][j]==1)&#123; System.out.print(i+ &quot;-&gt;&quot;); j-=value[i]; &#125; i--; &#125;// for(i=1;i&lt;=cate;i++)&#123;// for(j=1;j&lt;=cubage;j++) &#123;// System.out.print(dp[i][j]+&quot; &quot;);// &#125;// System.out.println();// &#125;&#125; 必须装满此时相当于必须从[0][0]位开始转移方程，可以在初始化的时候讲第一行[0][1~cubage]赋值为-1，在判断转移条件的时候如果为-1则不转移123456789101112131415161718192021222324252627282930313233private static void parse01Full(int[] value, int[] cost, int cubage, int cate) &#123; int i=0,j=0; //dp[i][j]表示容量为j且物品种类为i个时的最优解（最大价值） int[][] dp = new int[cate+1][cubage+1]; //path[][]用于还原路径 int[][] path = new int[cate+1][cubage+1]; dp[0][0]=0; //初始化的时候将不是从0开始// for(i=1;i&lt;cate;i++)// dp[i][0]=-10000; //可以将非[0][0]值为-1，再判断转移的时候为-1则不转移 //不过也可以直接赋为负无穷，这样判断大小的时候同样不会转移 for(i=1;i&lt;cubage;i++) dp[0][i]=-10000; for(i=1;i&lt;=cate;i++)&#123; for(j=1;j&lt;=cubage;j++)&#123; //dp[i][j]= max(dp[i-1][j-k*cost[i]]+k*value[i]) , k=0|1 // 先默认不放入，即此时容量为j也只放前i-1个物品 dp[i][j]=dp[i-1][j]; //如果容积够，并且放入之后价值提升（j-cost[i]容积下放入前i-1个商品前提下再放入当前商品），则放入 if(cost[i]&lt;=j &amp;&amp; (dp[i-1][j-cost[i]]+value[i])&gt;dp[i-1][j]) &#123; dp[i][j] = dp[i - 1][j - cost[i]] + value[i]; path[i][j]=1; &#125; &#125; &#125; for(i=1;i&lt;=cate;i++)&#123; for(j=1;j&lt;=cubage;j++) &#123; System.out.print(dp[i][j]+&quot; &quot;); &#125; System.out.println(); &#125;&#125; 滚动优化1234567891011121314151617181920private static void parse01Update(int[] value, int[] cost, int cubage, int cate) &#123; int i=0,j=0,k=0; //dp[2][j] 当前价值只与上层相关，可优化为滚动2*cubage数组。 int[][] dp = new int[2][cubage+1]; for(i=0;i&lt;=cate;i++)&#123; k=1-k;//也可转为k^1 for(j=0;j&lt;=cubage;j++)&#123; if(i==0||j==0) dp[k][j]=0; else&#123; dp[k][j]=dp[1-k][j]; if(cost[i]&lt;=j &amp;&amp; (dp[1-k][j-cost[i]]+value[i])&gt;dp[1-k][j]) &#123; dp[k][j] = dp[1-k][j-cost[i]] + value[i]; &#125; &#125; &#125; &#125; System.out.println(dp[k][cubage]); //凡是可以滚动的，必定可以降维&#125; 一维数组优化1234567891011121314151617private static void parse01Optimize(int[] value, int[] cost, int cubage, int cate) &#123; int i=0,j=0,k=0; //dp[] 只与上层左侧部分相关，优化为一维数组 //max(dp[i-1][j-cost[i]]+value[i] , dp[i-1][j]) int[] dp = new int[cubage+1]; for(i=0;i&lt;=cate;i++)&#123; //依赖上层保存的j-cost[i]信息，所以此时需要从后往前更新 for(j=cubage;j&gt;=cost[i];j--)&#123; if(i==0) dp[j]=0; else if(dp[j-cost[i]]+value[i]&gt;dp[j]) dp[j]=dp[j-cost[i]]+value[i]; &#125; &#125; for(i=0;i&lt;=cubage;i++) System.out.print(dp[i]+&quot; &quot;);&#125; 完全背包状态转移方程：dp[i][j]= max(dp[i-1][j-k*cost[i]]+k*value[i]) , k=0|1…| (cubage/cost[i])//对于完全背包，如果w[i]&lt;=w[j] &amp;&amp; v[i]&gt;=v[j] 则可以直接无视j物品注意下面的代码中有一次优化12345678910111213141516171819202122232425262728293031private static void parseWQNormal(int[] value, int[] cost, int cubage, int cate) &#123; //注意此时物品并非只有一个，而是有无穷个，所以不只是放还是不放的问题 //dp[i][j]= max(dp[i-1][j-k*cost[i]]+k*value[i]) , k=0|1...| (cubage/cost[i]) int[][] dp = new int[cate+1][cubage+1]; int i=0,j=0; for(i=0;i&lt;=cate;i++)&#123; for(j=0;j&lt;=cubage;j++)&#123; if(i==0||j==0) dp[i][j]=0; else &#123; dp[i][j] = dp[i-1][j];// for(int k=1;k&lt;=j/cost[i];k++)&#123;// //注意此时j:0-&gt;cubage 其实每次都是以当前点重新计算，会重复计算// dp[i][j] = Math.max(dp[i][j],dp[i-1][j-k*cost[i]]+k*value[i]);// &#125; //计算dp[i][j]的时候其实考虑的是 max(dp[i-1][j-k*cost[i]]+k*value[i]) , k=0|1...| (cubage/cost[i]) //计算dp[i][j+cost[i]]的时候考虑的是 max(dp[i-1][(j+cost[i])-k*cost[i]]+k*value[i]) , k=0|1...| (cubage/cost[i]) //可以看出，dp[i][j+cost[i]] = max(dp[i][j]+value[i],dp[i-1][j+cost[i]]) if (j &gt;= cost[i] &amp;&amp; (dp[i][j]&lt;(dp[i][j-cost[i]]+value[i]))) &#123; //注意与01背包的不同点 dp[i][j] = dp[i][j-cost[i]]+value[i]; &#125; &#125; &#125; &#125; for(i=1;i&lt;=cate;i++)&#123; for(j=1;j&lt;=cubage;j++) &#123; System.out.print(dp[i][j]+&quot; &quot;); &#125; System.out.println(); &#125;&#125; 同样可以用一维数组优化12345678910111213141516171819private static void parseWQOptimize(int[] value, int[] cost, int cubage, int cate) &#123; int[] dp = new int[cubage+1]; int i=0,j=0; for(i=0;i&lt;=cate;i++)&#123; //依赖上次保存的同层j-cost[i]信息，所以此时需要从前往后更新 //注意当j&lt;=cost[i]时 for(j=cost[i];j&lt;=cubage;j++)&#123;//注意此处与01背包区别 if(i==0) dp[j]=0; else&#123; if(dp[j-cost[i]]+value[i]&gt;=dp[j]) dp[j]=dp[j-cost[i]]+value[i]; &#125; &#125; &#125; for(j=1;j&lt;=cubage;j++) &#123; System.out.print(dp[j]+&quot; &quot;); &#125;&#125; 多重背包123456789101112131415public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int cubage = sc.nextInt(); int cate = sc.nextInt(),i=1; int[] value = new int[cate+1]; int[] cost = new int[cate+1]; int[] count = new int[cate+1]; while(i&lt;=cate)&#123; cost[i]=sc.nextInt(); value[i]=sc.nextInt(); count[i]=sc.nextInt(); i++; &#125; parseDCOptmize(value,cost,count,cubage,cate);&#125; 常规思路复杂度仍然是O(cubage*cate*sum(count[i]))1234567891011121314151617181920212223private static void parseDCNormal(int[] value, int[] cost, int[] count, int cubage, int cate) &#123; int[][] dp = new int[cate+1][cubage+1]; int i=0,j=0; //dp[i][j]= max(dp[i-1][j-k*cost[i]]+k*value[i]) , k=0|1...|count[i] for(i=0;i&lt;=cate;i++)&#123; for(j=cost[i];j&lt;=cubage;j++)&#123; if(i==0||j==0) dp[i][j]=0; else &#123; int min = Math.min(count[i], j / cost[i]); for (int k = 0; k &lt;= min; k++) &#123; dp[i][j] = Math.max(dp[i][j], dp[i-1][j-k*cost[i]] + k * value[i]); &#125; &#125; &#125; &#125; for(i=1;i&lt;=cate;i++)&#123; for(j=1;j&lt;=cubage;j++) &#123; System.out.print(dp[i][j]+&quot; &quot;); &#125; System.out.println(); &#125;&#125; 一个容易想到的优化方案是转化为01背包，但是按照二进制分割，可以保证复杂度为O(cubage*sum(log2count[i])) 123456789101112131415161718192021222324252627282930313233343536373839404142private static void parseDCOptmize(int[] value, int[] cost, int[] count, int cubage, int cate) &#123; //注意如果count[i]*cost[i]&gt;cubage，其实等同于完全背包 //此时需要用到二进制思想对物品进行分割，将一种多件物品转化为多种一件物品，转化为01背包问题 //思考：二进制数每一位0表示不取，1表示取，这样我们就可以取遍所有的数 //过程：对于第i件物品，将count[i]分解为若干个数的组合，使得参数可以组合成任意小于等于count[i]的件数 //比如7=111，分解为001,010,100可表示任意&lt;=7的数；13=1101，分解为001,010,100,0110前三数表示&lt;=7,加上0110=6，可表示&lt;=13的数 //系数分别为1,2,4,...,2^(k-1),count[i]-2^k+1，k是满足count[i]-2^k+1&gt;0的最大整数 int i=1,j=0,cate_new=//下面给出转换代码 int[] value_new = new int[1000];//取1000最大 int[] cost_new = new int[1000];//取1000最大 while(i&lt;=cate)&#123; for(j=1;j&lt;=count[i];j&lt;&lt;=1)&#123;//右移 value_new[cate_new] = j*value[i]; cost_new[cate_new]=j*cost[i]; cate_new++; count[i]-=j; &#125; if(count[i]&gt;0)&#123; value_new[cate_new]=count[i]*value[i]; cost_new[cate_new]=count[i]*cost[i]; &#125;else if(i==cate)&#123; cate_new--; &#125; i++; &#125;// for(i=0;i&lt;=cate_new;i++)// System.out.print(value_new[i]+&quot;:&quot;+cost_new[i]+&quot; &gt;&quot;);// System.out.println(cate_new); //之后便等同于01背包了 int[] dp = new int[cubage+1]; for(i=0;i&lt;=cate_new;i++)&#123; //依赖上层保存的j-cost[i]信息，所以此时需要从后往前更新 for(j=cubage;j&gt;=cost_new[i];j--)&#123; if(i==0) dp[j]=0; else if(dp[j-cost_new[i]]+value_new[i]&gt;dp[j]) dp[j]=dp[j-cost_new[i]]+value_new[i]; &#125; &#125; for(i=0;i&lt;=cubage;i++) System.out.print(dp[i]+&quot; &quot;);&#125; 其实也有O(cate*cubage)的算法，参考多重背包单调队列优化 参考链接： 白话01背包 多重背包模板 流传颇广的背包九讲 dp背包问题小结 背包问题详解 背包问题详解与实现","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://buaanie.github.io/categories/算法笔记/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://buaanie.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://buaanie.github.io/tags/动态规划/"},{"name":"背包问题","slug":"背包问题","permalink":"https://buaanie.github.io/tags/背包问题/"}]},{"title":"网络复习","slug":"网络复习","date":"2017-09-24T04:17:00.000Z","updated":"2017-09-27T01:49:44.054Z","comments":true,"path":"2017/09/24/网络复习/","link":"","permalink":"https://buaanie.github.io/2017/09/24/网络复习/","excerpt":"体系机构 TCP/IP分层 功能及协议 应用层 传输单位：数据包任务：提供系统与用户接口功能：①文件传输②访问与管理③电子邮件 …协议：FTP、SMTP、POP3、HTTP 传输层 传输单位：报文段（TCP）或数据报（UDP）任务：主机中进程间通信功能：①为端到端提供可靠的传输服务②为端到端提供流量控制、差错控制、服务质量管理等服务协议：TCP、UDP 网络层 传输单位：数据报硬件：路由器任务：①将传输层传下来的报文段封装成组②选择适当路由，将分组交付给目标主机功能：①为传输层服务②组包和拆包③路由选择④拥塞控制协议：ICMP、ARP、RARP、IP、IGMP 链路层 传输单位：帧（网络传输最小单位）硬件：交换机、网桥任务：将网络层IP数据报组装成帧功能：①数据连接的建立、拆除、分离②帧定界和帧同步③差错检测协议：PPP、HDLC、ARQ 物理层 传输单位：比特硬件：集线器，中继器（数字信号）、放大器（模拟信号）任务：透明的传输比特流功能：为数据端设备提供数据通路","text":"体系机构 TCP/IP分层 功能及协议 应用层 传输单位：数据包任务：提供系统与用户接口功能：①文件传输②访问与管理③电子邮件 …协议：FTP、SMTP、POP3、HTTP 传输层 传输单位：报文段（TCP）或数据报（UDP）任务：主机中进程间通信功能：①为端到端提供可靠的传输服务②为端到端提供流量控制、差错控制、服务质量管理等服务协议：TCP、UDP 网络层 传输单位：数据报硬件：路由器任务：①将传输层传下来的报文段封装成组②选择适当路由，将分组交付给目标主机功能：①为传输层服务②组包和拆包③路由选择④拥塞控制协议：ICMP、ARP、RARP、IP、IGMP 链路层 传输单位：帧（网络传输最小单位）硬件：交换机、网桥任务：将网络层IP数据报组装成帧功能：①数据连接的建立、拆除、分离②帧定界和帧同步③差错检测协议：PPP、HDLC、ARQ 物理层 传输单位：比特硬件：集线器，中继器（数字信号）、放大器（模拟信号）任务：透明的传输比特流功能：为数据端设备提供数据通路 链路层功能：链路管理；帧同步（定界）；差错控制；透明传输；组帧：帧头+帧尾（明确帧开始和结束位置；字符填充、比特填充 首尾标记，注意MAC帧无需帧结束符）差错控制：奇偶校验、循环冗余 （注意这里的差错控制指的是无比特差错，但仍可能发生帧丢失、镇重复、帧失序等传输差错，因特网使用的ip协议是无连接的，传输是不可靠的，但是网络设计本来就是由用户主机来负责数据传输可靠性的，具体解释是依靠传输层的TCP协议实现端到端的可靠传输，例如主机B发现传输数据有差错则通知主机A重新发送相关部分数据）流量控制与可靠传输： 流量控制：停止-等待；滑动窗口； 可靠传输：滑动窗口（发送方维持发送窗口，代表已发送待确认或待发送的帧；接收方维持接受窗口，表示可接受的帧序列号范围.只有接收窗口向前滑动时发送窗口才可能向前滑动）； 停止-等待：发送窗口大小=1，接收窗口大小=1；发送一帧-等待-确认一帧-发送下一帧 后退N帧：发送窗口&gt;1，接收窗口=1；发送方连续发送n帧-接收方确认前m帧-发送方重发m-n帧；窗口大小W &lt; 2n -1 选择重传：发送&gt;1，接收&gt;1；传输过程中若中间某帧出错，则接收方暂存其后帧，等待重传该帧，避免全部重传。 局域网与以太网局域网即小范围内通过传输介质（双绞线、同轴电缆）多台计算机或通信设备组成的互联网络，目前主要是以太网标准。以太网：采用总线拓扑结构，所有计算机共享一条中线，信息以广播形式传播。采用无连接、不编号、无确认的数据帧传输方式（一般局域网信道质量好）。当数据传输过程中发生碰撞时，提供重传机制。以太网帧：MAC地址一共48bit（6B，高24厂商代码，低24位网卡序列号）。网卡从网络上收到每一个MAC帧，都先检查帧中MAC地址，匹配则接收该帧。以太网帧可以分为单播帧、组播帧、广播帧。MAC帧最短帧长度为64B，首尾长度为18B，数据部分占46B ~1500B（总线型网络多采用CSMA/CD协议即带冲突检测的载波侦听多路访问协议（先听后发、边听边发、冲突停发，随机重发），协议规定了最短帧长度为64B，小于64B的都是因冲突而异常终止的无效帧）。设备: 网桥：多个端口，每个端口连接一个网段的局域网。网桥从一个端口收到一帧，先暂存在缓存中（存储转发），如该帧无错误且目的MAC地址属于另一网段（同一网段则丢弃无需转发），则通过查找转发表将该帧从相应端口发出。 透明网桥：利用生成树算法，自动生成没有环路的转发路由。转发路由格式：源MAC地址-进入端口-时间戳。 交换机：多端口网桥，具备自动寻址及交换功能（存储转发或直通），可以隔离冲突域。（e.g. 送信，集线器送给所有人，自行判断是否接收，交换机会学习记录收信人地址）。 网桥一般连接局域网网段，而交换机每个端口一般直接与主机相连。 网络层功能：①异构网络互连②路由与转发③拥塞控制 互连中继：物理层：中继器或集线器；链路层：网桥或交换机；网络层：路由器；网络层以上：网关。 路由与转发：路由选择：根据路由选择算法确定分组报文盖被传输到哪条路线，生成路由表。 分组转发：根据路由表将数据报从合适路由器端口转发。 拥塞控制：拥塞检测、报告与调整 路由算法 静态路由（手动配置）、动态路由（距离向量路由算法、链路状态算法） 距离路由算法：所有节点定期将整个路由表传送给所有与之直接相邻的节点，路由表中包括每条路径的目的节点及路径跳数，RIP算法。 链路状态算法：每个节点测试定期测试与之直连的节点间的链路，定期将链路信息广播给所有其他节点，其他节点接收所有节点的链路状态信息更新自己的网络拓扑视野图，利用Dijkstra算法计算路由。 路由选择协议分层次：域内路由选择（内部网关协议IGP：RIP、OSPF），域间路由选择（外部网关协议EGP：BGP） IPv4 ip数据报首部是60B，其中21~60B四可选字段和填充，前20B是固定长度，首部长度一定为4B的整数倍。首部重要字段：总长度，占2B16位，即ip数据报最长64KB（MAC帧最长1500B，超出要对数据报分片）；标志：MF：标记该分片是否是最后一个分片。DF：是否允许传输。片偏移：以8B为单位的偏移量。 e.g.原数据报总长度3820B，分片长度不超过1420B，则分成3片：1420+1420+1020（1400+1400+1000），MF（1,1,0），DF（0,0,0），片偏移（0，1400/8=175,350） ipv4地址，长度为32位 A类网络地址，前八位为网络号，且第一位为0。1~126 B类网络地址，前16位为网络号，且前两位位10。128.1~191.255 C类网络地址，前24位为网络号，且前三位为110。192.0.1~223.255.255 NAT，有些机构不需要连接互联网，只需内部主机通信，避免浪费全球IP资源，规定以下地址为内部专用地址（可重用地址） 10.0.0.0 ~ 10.255.255.255 （相当于一个A类网络） 172.16.0.0 ~ 172.31.255.255 （相当于一个B类网络） 192.168.0.0 · 192.168.255.255（相当于一个C类网络） NAT协议（NAT路由器至少有一个可用的全球IP）将专用网内部IP地址转化为有效全球IP 子网划分与子网掩码 ip地址={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;} ip地址与指望艳母按位与，得到网络地址。 路由器从分组头部得到目的ip地址，然后①计算与路由器直接相连网络的子网掩码^该ip地址，查看是否与该网络的地址相匹配，匹配则交付，②如果有自定目的ip的特定路由则交给指明的下一跳路由，③对路由表每一行计算网络是否匹配。有默认路由则交给默认路由，无则报告转发分组出错。 CIDR 超网，ip={&lt;网络前缀&gt;,&lt;主机号&gt;} / 网络前缀长 协议 ARP： ip地址转为MAC地址，每个主机都动态维护AR高速缓存表。ARP请求分组是广播，但是ARP响应是单播。 当源主机（或路由器）向本局域网的目的主机发送ip分组时，先在本机ARP缓存中查找，有则直接将对应硬件地址填入MAC帧目的mac地址；没有则在局域网内广播，获取目的主机ARP响应，更新ARP缓存。 如果源主机与目的主机不在同一局域网，则需要通过arp找到位于本局域网上的某个路由器硬件地址，将arp请求发给该路由器让该路由器转发给下一个网络（的路由器），注意目的主机发送ARP响应报文时实际是由目的主机所在局域网路由器发送，即目的MAC地址是路由器的地址。 DHCP：DHCP服务器为主机动态分配IP，使用UDP报文传输。 ICMP：检测到数据报错误的路由器或主机通过ICMP控制消息告诉发送数据的主机错误类型。（ICMP差错报文：不可达、源站抑制、超时、参数错误、改变路由；ICMP询问报文：回送请求和回答报文、时间戳请求和回答报文、掩码地址请求和回答报文、路由器询问和通告报文）。ping是应用层直接使用网络层ICMP的例子。 设备路由器：路由选择、分组转发 路由选择算法得到网络拓扑结构，得到路由表；由路由表得到转发表 路由器处理过程：线路上接收分组，①处理物理层数据（比特流）；②处理链路层数据（去掉帧头帧尾），得到IP数据报；③进行网络层数据处理，如果接收的分组时路由器间交换路由信息分组（RIP、OSPF等），则进行路由选择处理；如果得到的是数据分组，则按照分组首部中的目的地址查找转发表，通过交换结构将分组传递至合适的输出端口。 ④从交换结构传过来的分组先进行缓存，链路层模块给分组加上链路层头部和尾部，再交给物理层发送到外部路线。 传输层功能网络层提供了ip到ip的传输服务，而且是不可靠的，所以提出传输层。为主机提供应用程序间（进程间）的通信，即端到端通信，且可以提供可靠服务。 提供进程间的逻辑通信服务（无实际物理连接） 差错检验（对收到的报文首部和数据部分都进行差错检验，而网络层只检查IP数据报首部） 提供无连接（UDP）或面向连接（TCP，握手，流量控制，拥塞控制）的服务 复用和分用 寻址与端口链路层按照MAC地址寻址，网络层按IP寻址，传输层按照端口号寻址。端口可以看做应用层进程的标志。本机端口可以用16位端口号（共65536个端口号）来表示。 熟知端口（保留端口）：0 ~ 1023 登记端口：1024~40151 客户端端口（临时端口）：49152 ~ 65535套接字 = (主机IP地址，端口号) ，通过ip地址和端口号唯一确定一个连接，即套接字Socket。 TCP和UDPudp：传输前无需连接，达到后也无需确认；不可靠；报文头部短（8B），开销小，时延小（网络拥塞不会导致源主机发送速率降低）。tcp：面向连接，不能广播或多播；可靠交付；报文头部长，开销大。 UDP： 首部：源端口、目的端口、长度、校验和（伪首部、首部和数据，伪首部不发送，只是计算校验和时候用到）。 TCP： 首部：源端口、目的端口、序号seq（报文段序号，以字节为单位，TCP面向字节流）、确认号ack（确认号为N+1，表示前N字节已收到）、数据偏移（首部长度）…、确认比特ACK（当ACK=1时字段有效，一旦TCP连接建立，所有报文该字段都为1）、复位比特RST（置1表示需要重新连接）、同步比特SYN（置1表示是一个请求连接或者接受连接报文，此时报文不能携带数据）、终止比特FIN（置1表示该报文发送端数据发送完毕）、窗口字段（表示接收方还有多少缓存空间，控制对方发送数据量）、校验和（首部和数据） 三次握手：TCP连接的主机端口叫套接字，每一个TCP连接={socket1,socket2}={(ip1:port1),(ip2,port2)} 客户机A -&gt; 服务器B，发送SYN报文，SYN=1，选择seq=x，表示传输数据时第一个字节序号为x； B收到A的数据报，同意发送确认报文，同样SYN=1,ACK=1,ack=x+1，自己选择序号seq=y； A收到确认，也发送确认。ACK=1,seq=x+1,ack=y+1；A通知上层应用进程连接建立，B收到A的确认也通知上层进程连接建立。此后SYN比特置0，报文可以携带数据。 四次握手：传输结束后，任一方可以请求释放连接 主机A应用进程先发出连接释放报文等待B确认，FIN比特置1，FIN=1,seq=u，注意此时A不能发送数据，但服务器B仍能向A发送数据。 B确认A的释放请求。ACK=1,ack=u+1,seq=v，通知上层应用要断开连接。此时，B不再接收A的数据，但是B仍能发送，A也能接收。 如果B没有要向A发送的数据，通知上层应用释放连接。FIN=1,ACK=1,seq=w,ack=u+1；注意这里的w&gt;v表示B仍然发送了w-v字节数据。 A收到B的连接释放请求，也进行确认。ACK=1,ack=w+1,seq=u+1； 经过time_wait时间，（2MSL（最长报文寿命））后TCP连接真正释放（防止A的确认报文丢失，B没有正常关闭）。 TCP可靠传输 数据编号及确认 + 重传机制（在平均往返时延RTT时间内没有收到确认报文，则对报文进行重传） 流量控制：滑动窗口协议；维持计时器，计时器周期探测接收窗口大小。 拥塞控制：慢开始算法（加倍），拥塞避免算法（超过阈值，每次加1，拥塞阈值变为拥塞窗口大小一半），快重传算法（三次重复确认立即重传），快恢复算法（拥塞时发送窗口大小从新阈值开始） 作用：每个IP数据报独立选择路由，在到达目的主机时可能失序；数据报中的TTL可能中途置0，报文丢弃，需要重传；路由器来不及处理大量数据报，导致部分数据被丢弃，需要重传。 应用层 应用层协议 传输层协议 DNS TCP/UDP FTP TCP RIP(路由选择) UDP SMTP TCP HTTP TCP DNS系统：根域名服务器，顶级域名服务器，权限域名服务器，本地域名服务器。DNS协议是应用层协议，主机向本地域名服务器采用递归查询方式查找域名的IP地址（主机询问本地域名服务器，找不到则本地域名服务器向根服务器查询，根服务器告诉本地域名服务器在哪一个顶级域名服务器上查询，顶级上找不到就告诉本地域名服务器到哪个权限域名服务器上查询；也有本地域名服务器递归查询方式）。 FTP协议，使用TCP协议进行可靠传输，端口通常为20/21（会有临时端口）。 SMTP、POP3 邮件协议。 HTTP 在客户端（如浏览器）和WWW服务器之间进行交互的协议。是面向事务的应用层协议，基于TCP提供可靠传输，服务器默认监听80端口（即在80端口上监听连接请求）。 分为请求报文、响应报文 状态码：1xx:临时响应；2xx:响应请求成功；4xx:请求出错；5xx:服务器内部错误； 参考链接： OSI分层协议总结 网络编程详解：分层、协议与实现 tcp/ip 协议族 网络协议总结 http响应状态码 http缓存及CND http代理原理及实现 访问网站域名过程 https原理及过程","categories":[{"name":"网络","slug":"网络","permalink":"https://buaanie.github.io/categories/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://buaanie.github.io/tags/网络/"},{"name":"基础","slug":"基础","permalink":"https://buaanie.github.io/tags/基础/"}]},{"title":"最长公共子序列","slug":"最长公共子序列","date":"2017-09-09T16:54:45.000Z","updated":"2017-09-17T17:12:56.730Z","comments":true,"path":"2017/09/10/最长公共子序列/","link":"","permalink":"https://buaanie.github.io/2017/09/10/最长公共子序列/","excerpt":"问题描述对于母串X={x1,x2,⋯,xm}, Y={y1,y2,⋯,yn}, 求LCS与最长公共子串。假设 Zk={z1,z2,⋯,zk} 是 X 与 Y 的 LCS， 可以观察到 如果xm=yn，则 zk=xm=yn，有 Zk−1 是 Xm−1、Yn-1 的 LCS； 如果xm≠yn ，则 Zk 是 Xm 与 Yn−1 的LCS，或者 Xm−1 与 Yn 的 LCS","text":"问题描述对于母串X={x1,x2,⋯,xm}, Y={y1,y2,⋯,yn}, 求LCS与最长公共子串。假设 Zk={z1,z2,⋯,zk} 是 X 与 Y 的 LCS， 可以观察到 如果xm=yn，则 zk=xm=yn，有 Zk−1 是 Xm−1、Yn-1 的 LCS； 如果xm≠yn ，则 Zk 是 Xm 与 Yn−1 的LCS，或者 Xm−1 与 Yn 的 LCS 利用动态规划思想，不难写出状态转移方程：12if X[i]=Y[j] then LCS(i,j) = LCS(i-1j-1)+1 else LCS(i,j) = max(LCS(i-1,j) , LCS(i,j-1)) 也就很容易有代码： 1234567891011121314151617 public static int lcs(String X, String Y) &#123; int lx = X.length(); int ly = Y.length(); int[][] r = new int[lx+1][ly+1]; for (int i = 0; i &lt;= lx; i++) &#123; for( int j = 0; j &lt;= ly; j++) &#123; if(i == 0 || j == 0) &#123; r[i][j] = 0; &#125; else if (X.charAt(i-1) == Y.charAt(j-1)) &#123; r[i][j] = r[i-1][j-1] + 1; &#125; else &#123; r[i][j] = max(r[i - 1][j], r[i][j - 1]); &#125; &#125; &#125; return c[lx][ly];&#125; 实际上这样带来的空间消耗还是比较大，观察到每次实际只用到了上一行保存的数字（不考虑复原LCS，只考虑计算其长度），可以将m*n的数组转为2*n的数组。代码如下：1234567891011121314151617181920public static int lcs(String X, String Y) &#123; int lx = X.length(); int ly = Y.length(); int[][] r = new int[2][ly+1]; r[0][0]=0; int k =0; for (int i = 0; i &lt;= lx; i++) &#123; k = 1-k; for( int j = 1; j &lt;= ly; j++) &#123; if(i == 0) &#123; r[i][j] = 0; &#125; else if (X.charAt(i-1) == Y.charAt(j-1)) &#123; r[k][j] = r[1-k][j-1] + 1; &#125; else &#123; r[k][j] = Math.max(r[1-k][j], r[k][j - 1]); &#125; &#125; &#125; return r[k][ly];&#125; 求最长公共子串与上面类似，转移方程为：12if X[i]=Y[j] then LCS(i,j) = LCS(i-1j-1)+1 else LCS(i,j) = 0","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://buaanie.github.io/categories/算法笔记/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://buaanie.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://buaanie.github.io/tags/动态规划/"}]},{"title":"排序算法","slug":"排序算法","date":"2017-09-02T04:54:45.000Z","updated":"2017-09-17T17:08:41.306Z","comments":true,"path":"2017/09/02/排序算法/","link":"","permalink":"https://buaanie.github.io/2017/09/02/排序算法/","excerpt":"JDK中的排序算法Java 数组方法中的Sort方法(1.7开始多了基于TimSort的parallelSort，是一种优化过的归并排序，适合多核对大数组切分然后归并）其实包含三种排序算法，当待排序数组长度小于47时，采用插入排序，小于286时采用快速排序，大于286则采用归并排序，由此可见三种排序在不同数据规模下的效率。下面以升序为例介绍三种算法。","text":"JDK中的排序算法Java 数组方法中的Sort方法(1.7开始多了基于TimSort的parallelSort，是一种优化过的归并排序，适合多核对大数组切分然后归并）其实包含三种排序算法，当待排序数组长度小于47时，采用插入排序，小于286时采用快速排序，大于286则采用归并排序，由此可见三种排序在不同数据规模下的效率。下面以升序为例介绍三种算法。 插入排序描述 :从前往后，当后数小于前数时，即开始把后数往前挪动，直至放入正确位置。代码 :1234567891011121314void insertSort(int[] a, int left, int right) &#123; for (int i = left+1; i &lt;=right; i++) &#123; if(a[i]&lt;a[i-1])&#123; int j= i,t = a[j]; while(j&gt;left &amp;&amp; a[j-1]&gt;t)&#123; //这里不用swap直接前数后移即可 a[j]=a[j-1]; j--; &#125; //将记录下的后数放入正确位置 a[j]=t; &#125; &#125;&#125; 官方实现如下 :123456789101112void insertSort(int[] a, int left, int right) &#123; for (int i = left, j = i; i &lt; right; j = ++i) &#123; int ai = a[i + 1]; while (ai &lt; a[j]) &#123; a[j + 1] = a[j]; if (j-- == left) &#123; break; &#125; &#125; a[j + 1] = ai; &#125;&#125; 插入排序描述 : 关于插入排序的解释，觉得最清楚的一篇博客是快速搞定快速排序。快速排序思想是①选取基准数（一般取left、right、middle的中位数）②分区，将比基准大的数放到基准右边，小于等于的数放在左边③对基准左右两个区间重复第二步，直至各区间只剩一个数。 快排过程可以理解成挖坑填数：1．i = L; j = R; 将基准数挖出形成第一个坑a[i]。2．j–由后向前找比基准小的数，找到后挖出此数填前一个坑a[i]中。3．i++由前向后找比基准大的数，找到后也挖出此数填到前一个坑a[j]中。4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。 实现 :123456789101112131415161718192021222324//以l为基准//按照partition函数和sort函数分开的思想：int quickSort(int[] s, int l, int r)&#123; // 基准x(pivot)选取s[l]，实际可以用middle，计算middle技巧 (l+r)&gt;&gt;&gt;1 // &gt;&gt;为算术右移，&gt;&gt;&gt;为无符号右移 int i =l,j=r,x=s[i]; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; s[j]&gt;=x) j--; s[i]=s[j]; while(i&lt;j &amp;&amp; s[i]&lt;=x) i++; s[j]=s[i]; &#125; s[i]=x;//回填基准，此时基准左右分区。 return i;//即返回基准分割的位置&#125;void quickSort(int[] s, int l, int r) &#123; if(l&lt;r)&#123; int i = quickSort(int[] s, int l, int r); quickSort(s,l,i-1); quickSort(s,i+1,r); &#125;&#125; 官方实现 :1234567891011121314151617181920212223242526/*官方实现采用了双基准的实现方法，而且有很多优化，面对包含大量重复元素的数组效率更高，这里只写出快排示例*选择两个枢纽元p1,p2，一般选择起始元素a[left]和末尾元素a[right]。*假设p1&lt;p2，如果不是就交换。*基于p1,p2将整个数组分成三部分，小于p1的，大于p1 且 小于p2的，大于p2的。*递归排序这三个部分。*/void dual_qsort(int low,int high,int[] a)&#123; if(low&gt;high) swap(low,high); int pivotL=low,pivotR=high; int tmpL=low,tmpR=high; int index=low+1; while(index&lt;=tmpR)&#123; if(a[index]&lt;pivotL) swap(a[index++],a[tmpL++]); else if(a[index]&gt;pivotR) swap(a[index],a[tmpR--]); else index++; &#125; swap(a[--tmpL],a[low]); swap(a[++tmpR],a[high]); dual_qsort(low,tmpL-,a); dual_qsort(tmpL+，tmpR-,a); dual_qsort(tmpR+,high,a);&#125; 归并排序描述 : 递归分解数组，在合并已排序的子数组。先介绍合并两个已排序数组：123456789101112131415161718//n为a[]的长度void mergeArray(int[] a, int[] b, int[] c) &#123; int i, j, k; i = j = k = 0; int n = a.length,m = b.length; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (a[i] &lt; b[j]) c[k++] = a[i++]; else c[k++] = b[j++]; &#125; while (i &lt; n) c[k++] = a[i++]; while (j &lt; m) c[k++] = b[j++]; &#125; 直接上代码:1234567891011121314151617181920212223242526272829303132333435//合并的两个数组一定相邻，所以用low-mid,mid+1-high区分void merge(int[] a, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low,j = mid + 1;//左右待合并数组起始点 int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (a[i] &lt; a[j]) &#123; temp[k++] = a[i++]; &#125; else &#123; temp[k++] = a[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; temp[k++] = a[i++]; &#125; // 把右边边剩余的数移入数组 while (j &lt;= high) &#123; temp[k++] = a[j++]; &#125; //覆盖回写原数组 for (int l = 0; l &lt; temp.length; l++) &#123; a[l + low] = temp[l]; &#125;&#125;void mergeSort(int[] a, int low, int high) &#123; int mid = (low + high)&gt;&gt;&gt;1; if (low &lt; high) &#123; //归 mergeSort(a, low, mid); mergeSort(a, mid + 1, high); //并 merge(a, low, mid, high); &#125;&#125; 最后贴一下排序复杂度与稳定性 不稳定： 选择排序（selection sort）— O(n2)快速排序（quicksort）— O(nlogn) 平均时间, O(n2) 最坏情况; 对于大的、乱序串列一般认为是最快的已知排序堆排序 （heapsort）— O(nlogn)希尔排序 （shell sort）— O(nlogn)基数排序（radix sort）— O(n·k); 需要 O(n) 额外存储空间 （K为特征个数） 稳定： 插入排序（insertion sort）— O(n2)冒泡排序（bubble sort） — O(n2)归并排序 （merge sort）— O(n log n); 需要 O(n) 额外存储空间二叉树排序（Binary tree sort） — O(nlogn); 需要 O(n) 额外存储空间计数排序&gt;&gt;(counting sort) — O(n+k); 需要 O(n+k) 额外存储空间，k为序列中Max-Min+1桶排序 （bucket sort）— O(n); 需要 O(k) 额外存储空间","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://buaanie.github.io/categories/算法笔记/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://buaanie.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://buaanie.github.io/tags/排序/"},{"name":"源码","slug":"源码","permalink":"https://buaanie.github.io/tags/源码/"}]},{"title":"前端与反爬虫","slug":"prevent-spiders","date":"2017-08-28T02:36:00.000Z","updated":"2017-09-09T15:07:47.289Z","comments":false,"path":"2017/08/28/prevent-spiders/","link":"","permalink":"https://buaanie.github.io/2017/08/28/prevent-spiders/","excerpt":"本文转载自Litten，已获作者授权。 1. 前言对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是爬虫与反爬虫这一话题的由来。因为自己写过些爬虫，也见过一些非常让人头疼的网站，但是自己并非专业写爬虫，分析也远不如这一篇博客里面写得那么详细和专业，所以遇到这篇好文章，非常感慨，向原作者申请转载。","text":"本文转载自Litten，已获作者授权。 1. 前言对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是爬虫与反爬虫这一话题的由来。因为自己写过些爬虫，也见过一些非常让人头疼的网站，但是自己并非专业写爬虫，分析也远不如这一篇博客里面写得那么详细和专业，所以遇到这篇好文章，非常感慨，向原作者申请转载。 2. 常见反爬虫策略但是世界上没有一个网站，能做到完美地反爬虫。 如果页面希望能在用户面前正常展示，同时又不给爬虫机会，就必须要做到识别真人与机器人。因此工程师们做了各种尝试，这些策略大多采用于后端，也是目前比较常规单有效的手段，比如： User-Agent + Referer检测 账号及Cookie验证 验证码 IP限制频次 而爬虫是可以无限逼近于真人的，比如： chrome headless或phantomjs来模拟浏览器环境 tesseract识别验证码 代理IP淘宝就能买到 所以我们说，100%的反爬虫策略？不存在的。更多的是体力活，是个难易程度的问题。 不过作为前端工程师，我们可以增加一下游戏难度，设计出一些很(sang)有(xin)意(bing)思(kuang)的反爬虫策略。 3. 前端与反爬虫3.1 font-face拼凑式例子：猫眼电影 猫眼电影里，对于票房数据，展示的并不是纯粹的数字。页面使用了font-face定义了字符集，并通过unicode去映射展示。也就是说，除去图像识别，必须同时爬取字符集，才能识别出数字。 并且，每次刷新页面，字符集的url都是有变化的，无疑更大难度地增加了爬取成本。 3.2 background拼凑式例子：美团 与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。 并且不同页面，图片的字符排序也是有区别的。不过理论上只需生成0-9与小数点，为何有重复字符就不是很懂。 页面A：页面B： 3.3 字符穿插式例子：微信公众号文章 某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。这种方式虽然令人震惊…但其实没有太大的识别与过滤难度，甚至可以做得更好，不过也算是一种脑洞吧。 对了，我的手机流量可以找谁报销吗？ 3.4 伪元素隐藏式例子：汽车之家 汽车之家里，把关键的厂商信息，做到了伪元素的content里。这也是一种思路：爬取网页，必须得解析css，需要拿到伪元素的content，这就提升了爬虫的难度。 3.5 元素定位覆盖式例子：去哪儿 还有热爱数学的去哪儿，对于一个4位数字的机票价格，先用四个i标签渲染，再用两个b标签去绝对定位偏移量，覆盖故意展示错误的i标签，最后在视觉上形成正确的价格… 这说明爬虫会解析css还不行，还得会做数学题。 3.6 iframe异步加载式例子：网易云音乐 网易云音乐页面一打开，html源码里几乎只有一个iframe，并且它的src是空白的：about:blank。接着js开始运行，把整个页面的框架异步塞到了iframe里面… 不过这个方式带来的难度并不大，只是在异步与iframe处理上绕了个弯（或者有其他原因，不完全是基于反爬虫考虑），无论你是用selenium还是phantom，都有API可以拿到iframe里面的content信息。 3.7 字符分割式例子：全网代理IP 在一些展示代理IP信息的页面，对于IP的保护也是大费周折。 他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。 3.8 字符集替换式例子：去哪儿移动侧 同样会欺骗爬虫的还有去哪儿的移动版。 html里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果…","categories":[{"name":"技术","slug":"技术","permalink":"https://buaanie.github.io/categories/技术/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://buaanie.github.io/tags/前端/"},{"name":"爬虫","slug":"爬虫","permalink":"https://buaanie.github.io/tags/爬虫/"},{"name":"转载","slug":"转载","permalink":"https://buaanie.github.io/tags/转载/"}]},{"title":"新一篇","slug":"新一篇","date":"2017-08-27T15:54:45.000Z","updated":"2017-09-10T07:37:34.972Z","comments":true,"path":"2017/08/27/新一篇/","link":"","permalink":"https://buaanie.github.io/2017/08/27/新一篇/","excerpt":"上一次正儿八经的写博客还是本科毕设的时候，那时候各种查资料，觉得很多东西需要自己整理到一起，方便后面查阅，而不用一页页翻收藏夹。但是后来写博客就太懒了，因为多数时候我都是遇到问题或者好奇什么技术才回去翻别人的博客，等自己看完之后其实很少继续思考，所以自己写博客的时候往往就几句话，然后贴一堆别人文章的链接。","text":"上一次正儿八经的写博客还是本科毕设的时候，那时候各种查资料，觉得很多东西需要自己整理到一起，方便后面查阅，而不用一页页翻收藏夹。但是后来写博客就太懒了，因为多数时候我都是遇到问题或者好奇什么技术才回去翻别人的博客，等自己看完之后其实很少继续思考，所以自己写博客的时候往往就几句话，然后贴一堆别人文章的链接。 后来get了利用Pocket+Evernote做知识整理的方法，微博、微信、知乎以及网页文章全部都进了印象笔记，然后定期归档，这套方法的确极大提高了收集的便利性，但是也让自己更懒了，大象更像是一个存档工具，而且我几乎没有编辑过。虽然中途也想结合workflow来做随感、灵感笔记，但依然很细碎的记录着。 之后某次阿里面试的时候，面试官问有没有写技术博客的习惯，我还挺“坦然”的说没有，和多数人一样没有坚持下去，但是自己有用印象笔记保存然后归档，当时面试官还帮我圆场。可能说起来没有坚持写博客是因为想找现成免费的博客站又觉得太丑（比如CSDN、博客园），自己动手搭又嫌麻烦（比如当时调WordPress），也尝试过简书之类的但是又纠结什么markdown…总之很多理由，工具重过心情。 回过头来，也是最近面试得到的一个感受，就是很多问题的确遇到过，一些知识点其实也是看过的，但是没有经常用到的确容易忘记，想了想也可能就是因为自己只是看过了、保存了，并没有自己去总结，去复述。什么东西自己学到了，再给别人讲一遍，其实是一个加强理解和记忆的过程，所以打算从现在开始把自己遇到的项目、研究的知识点好好地梳理记录下来，希望能更好的帮助自己成长成一个优秀的engineer吧。","categories":[{"name":"随感","slug":"随感","permalink":"https://buaanie.github.io/categories/随感/"}],"tags":[{"name":"随感","slug":"随感","permalink":"https://buaanie.github.io/tags/随感/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-26T01:49:58.573Z","updated":"2017-09-03T16:56:53.757Z","comments":true,"path":"2017/08/26/hello-world/","link":"","permalink":"https://buaanie.github.io/2017/08/26/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}